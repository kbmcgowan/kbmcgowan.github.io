<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.8">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>research – Kevin B. McGowan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-79bb3942e891885f9f7af119cd221462.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-3e2a9af25a307abeb180fa14d4508642.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="infographic.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Kevin B. McGowan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../research/index.html" aria-current="page"> 
<span class="menu-text">research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../teaching/index.html"> 
<span class="menu-text">teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../stuff/index.html"> 
<span class="menu-text">stuff</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv/index.html"> 
<span class="menu-text">cv</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">research</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="scrolling-columns" style="width: 100%;">
<div id="infographic">
<div class="rectangle-border inverted-text" style="border-color: #335AA4; background:#335AA4; margin-top: 50px;">
<p>“The thing about speech is, it varies.” (Remirez, in press). But for a number of historical and disciplinary reasons (see McGowan, in press), it feels normal for people in my field to talk about how listeners are “confronted with” tremendous variation in speech or to think about and write about variation as a big problem that listeners have to solve. I think this is a real shame.</p>
</div>
<div>
<p class="bubble" style="margin-top: 20px;">
Hi! My research takes the position that listeners are sensitive to patterns of covariation in speech and that knowing (more on ‘knowing’ later) these subtle patterns is part of what it means to truly know a language.
</p>
<p><img alt="a cartoon of Kevin by M.C. Nee" src="images/kevinCartoon.png" style="margin-left:70px; z-index: 10;"></p>
</div>
<div class="rectangle-border inverted-text" style="border-color: #335AA4; background:#335AA4; margin-top: 20px;">
<p>Why? Because speech is social. When we speak, we communicate not only our ideas, but also numerous social cues about who we are, where we come from, what we think you already know, who we think is listening, and many other details…</p>
</div>
<div style="position: relative;">
<p class="rectangle-border" style="float: left; width: 280px; margin-top: 50px; margin-left: 150px; border-color: #3B8686;">
Which is great because if people sound the way we expect them to, we’re able to understand them better (<a href="http://las.sagepub.com/content/early/2015/02/03/0023830914565191.abstract">McGowan, 2015</a>; <a href="LSA2012.svg" target="_blank">2012 LSA presentation</a>)
</p>
<p><img style="float: right;" width="468px" src="images/McGowan2014-faceByExperience.png" alt="proportion accurate transcriptions by visual stimulus and listener experience level"></p>
<p><img src="images/TTasian.png" style="width: 50px; position: absolute; top: 210px; right: 100px;" alt="Asian woman"> <img src="images/TTsilhouette.png" style="width: 50px; position: absolute; top: 210px; right: 50px;" alt="simple silhouette"> <img src="images/TTcaucasian.png" style="width: 50px; position: absolute; top: 210px; right: 0px;" alt="Caucasian woman"></p>
</div>
<div style="clear: both;">
<p class="rectangle-border" style="float: right; margin-top: 75px; margin-right: 100px; width: 375px; border-color: #3B8686; clear: both;">
This is true even when our expectations are based on stereotypes rather than authentic experience (McGowan, 2017)!
</p>
<p><img style="position: relative; top: 0px; float: left;" width="490px" src="images/McGowan2014-authenticityDetection.png" alt="proportion `is authentic' ratings to authentic and imitated Chinese-accented English"></p>
</div>
<div style="clear: both;">
<div class="rectangle-border inverted-text" style="border-color: #335AA4; background:#335AA4; margin-top: 20px; clear: both;">
<p>In <a href="http://journal.frontiersin.org/Journal/10.3389/fpsyg.2013.01015/abstract">Sumner, Kim, King, and McGowan (2014)</a> we propose a model (below) of how the linguistic and the social aspects of speech interact to support perception.</p>
</div>
<p><img style="display: block; margin-left: auto; margin-right: auto;" width="650px" src="images/SumnerEtAl2014-dualRoute.jpg" alt="Sumner et al. 2014, proposed dual route approach to speech perception"></p>
</div>
<div class="rectangle-border inverted-text" style="border-color: #335AA4; background:#335AA4; margin-top: 20px;">
<p>In this model, we propose that listeners process both phonetically cued social information and phonetically cued linguistic information prior to word recognition and that these dual routes can <em>interact</em> to guide and facilitate perception.</p>
</div>
<img style="width: 400px; float: left;" src="images/McGowanBabel2014-first.png">
<p class="rectangle-border" style="float: right; width: 400px;">
For example, when <a href="https://sppo.osu.edu/people/babel.6">Anna Babel</a> and I told Bolivian listeners to expect Quechua-accented Spanish, they perceived vowels completely differently than if they were told to anticipate a Spanish accent (<a href="https://www.cambridge.org/core/journals/language-in-society/article/abs/perceiving-isnt-believing-divergence-in-levels-of-sociolinguistic-awareness/E7498CECBC34889456FC3E168DCA0794">McGowan and Babel, 2020</a>)
</p>
<p class="rectangle-border" style="float: left; width: 375px; border-color: #3B8686;">
This suggests that <b>experienced listeners have detailed knowledge of phonetically-cued social information</b> —so expecting the variation consistent with a particular social category can change the way we perceive vowels. Social information isn’t noise to be thrown away, it is an essential part of the signal.
</p>
<p><img style="width: 400px; float: right;" src="images/McGowanBabel2014-second.png"></p>
<p><br style="clear: both;"></p>
<p class="rectangle-border inverted-text" style="border-color: darkorange; background: darkorange; margin-top: -10px;">
So here’s that word <em>know</em> again! Knowledge is not the same thing as <em>awareness</em>. We told listeners they’d changed speakers (from Quechua to Spanish or vice versa) and while they gave every indication of believing the switch their low level perceptual behavior stayed the same!
</p>
<!-- put Laycock & McGowan in press HERE -->
<div style="clear: both;">
<p><img src="images/kevinCartoon.png" style="float: left; z-index: 100;"></p>
<blockquote style="float:left; width: 300px; margin-left: 30px; text-align: center;" class="rightbubble blockquote">
So does all this knowledge and sensitivity only apply to social variation?
</blockquote>
</div>
<p class="rectangle-border" style="clear: both;">
First, some quick background on how sounds like [p], [t], and [k] differ from sounds like [b], [d], and [g] at the beginning of English words like <em>pit</em> and <em>bit</em>. What word is this native American English speaker saying? Does it sound like ‘pit’ or ‘bit’ to you? <br> <audio controls="" style="margin-top: 20px; margin-left: auto; margin-right: auto; clear: both;"> <source src="images/pit-noAspiration.wav" type="audio/wav"> <source src="images/pit-noAspiration.mp3" type="audio/mp3"> Your browser does not support the audio element. </audio>
</p>
<div style="position: relative;">
<p><img width="450px" src="images/pit-bit.png" alt="spectrograms of [pɪt] and [bɪt]"></p>
<p><span style="width: 480px; position: absolute; top: 60px; left: 460px; float: left;"> The image to the left is a spectrogram (frequency analysis over time) of the word <em>pit</em>. Hear the puff of air at the beginning? It is highlighted in blue. <audio controls="" style="margin-top: 50px; display: inline; float: left;"> <source src="images/pit.wav" type="audio/wav"> <source src="images/pit.mp3" type="audio/mp3"> Your browser does not support the audio element. </audio> </span></p>
<p><span style="width: 480px; position: absolute; top: 360px; left: 460px; float: left;"> <em>pit</em> and <em>bit</em> both start with the lips completely closed. One of the main differences between them is the duration of the puff of air, this duration is called VOT (voice onset time). <audio controls="" style="margin-top: 40px; display: inline; float: left;"> <source src="images/bit.wav" type="audio/wav"> <source src="images/bit.mp3" type="audio/mp3"> Your browser does not support the audio element.</audio> </span></p>
<span class="inverted-text" style="height: 240px; width: 33px; background: #335AA4; opacity:0.25; z-index: 2; padding: 0; float: left; position: absolute; left: 116px; top: 50px;">&nbsp;</span>
<h3 style="font: normal 24px Voces; display: inline; position: absolute; top: 50px; left: 20px;" class="anchored">
[pʰɪt]
</h3>
<h3 style="font: normal 24px Voces; display: inline; position: absolute; top: 345px; left: 20px;" class="anchored">
[bɪt]
</h3>
<p></p>
<p class="rectangle-border" style="border-color: #cccccc; margin-bottom: -10px; clear: both;">
At least in American English, that puff of air is so important that if we cut it out of <em>pit</em> (this was that first sound you played! ‘pit’ with the puff removed) it results in a word that sounds to English-knowing listeners a lot like <em>bit</em> —though probably with maybe a funny [b], and that funniness is every bit as interesting and important as the change from [p] to [b]!
</p>
<p><img style="float: left;" src="images/bend-bed-screen-off.png"></p>
<p class="rectangle-border" style="float: left; width: 350px; border-color: #335AA4;">
Another covarying feature is the way vowels before nasal consonants in English tend to be nasalized. Listeners can use this as soon as it becomes available, not only a large distinction like <em>bend</em>/<em>bed</em>… <audio controls="" styl="width:100px; float: left;"> <source src="BeddorEtAl2013/splices/bend-20-80.wav" type="audio/wav"> Your browser does not support the audio element. </audio> <audio controls="" styl="width:100px; float: left;"> <source src="BeddorEtAl2013/splices/bed.wav" type="audio/wav"> Your browser does not support the audio element. </audio>
</p>
<p class="oval-border" style="margin-left: 80px; width: 460px; border-color: #335AA4; float: left; text-align: center; margin-top: -150px; z-index: 5;">
but also a much more subtle distinction like the difference in nasalization between these two sound files. Can you hear a difference?
</p>
<div style="position: relative; clear: both;">
<p><img src="images/bend-bend.png" alt="spectrograms of early and late onset nasalization 'bend'" style="width: 450px; float: right; display: block;"></p>
<p><span style="position: absolute; top: 70px; left: 50px; width: 400px; float: left;"> This first recording has <b>late nasalization</b> starting 100 miliseconds after the [b]. <audio controls="" style="margin-top: 20px; display: inline; float: left;"> <source src="BeddorEtAl2013/splices/bend-60-40.wav" type="audio/wav"> Your browser does not support the audio element.</audio> </span></p>
<p><span style="position: absolute; top: 370px; left: 50px; width: 400px; float: left;"> This second recording has <b>early nasalization</b> starting 33 miliseconds after the [b]. <audio controls="" style="margin-top: 20px; display: inline; float: left;"> <source src="BeddorEtAl2013/splices/bend-20-80.wav" type="audio/wav"> Your browser does not support the audio element.</audio> </span></p>
</div>
<div style="clear: both;">
<img src="images/Beddor1b.png" style="float: right; width: 600px; margin: 0px;">
<p class="rectangle-border" style="float: left; width: 350px; margin-top: -30px; margin-left: 0px; ">
In an eye tracking task we found that listeners can use nasalization as soon as it is present. Looks to the heavily-nasalized word were, on average, 60 ms faster —the same average difference between early and late nasalization in the recordings (<a href="http://scitation.aip.org/content/asa/journal/jasa/133/4/10.1121/1.4794366">Beddor, McGowan, Boland, Coetzee, and Brasher, 2013)</a>.
</p>
</div>
<p><img src="images/brain-clip-art-18.gif" alt="a drawing of a human brain, I'm not sure whose" style="display: block; float:left; width: 320px; margin-top: 70px; clear: both; "></p>
<p class="rectangle-border" style="width: 450px; float: left; border-color: darkorange;">
Whether the information is social, contextual, articulatory, or idiosyncratic, we humans have an astonishing ability to attend to it, remember it, and activate it during perception. This ability, my research suggests, is not irrelevant to linguistic competence or even peripheral to it, it is fundamentally and centrally part of what it means to know and speak a human language.
</p>
<p class="bubble" style="width: 765px; height: 190px; clear: both; margin-left: auto; margin-right: auto;">
<img src="../images/harpers_engraving_carrier_pigeons.png" alt="engraving of carrier pigeons" width="175px" style="float: right; margin: 0px; valign: top;"> Thank you for reading! Ask me questions? And please enjoy this pigeon engraving as a free gift. And many, many thanks to my friend M.C. Nee for turning me into this cartoon.<br>
</p>
<p><img alt="a cartoon of Kevin by M.C. Nee" src="images/kevinCartoon.png" style="margin-left:150px; z-index: 10;"></p>
</div>
<p><span style="float: right;"><a class="button" href="mcgowan.bib">Download BibTex</a></span></p>


</div>
</div>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/vowel\.space");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>